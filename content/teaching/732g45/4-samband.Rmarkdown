---
# Course title, summary, and position.
weight: 5

# Page metadata.
title: Visualisering av samband mellan variabler
linktitle: Samband mellan variabler
date: "2020-08-06"
lastmod: "2020-08-06"
draft: false  # Is this a draft? true/false
toc: true  # Show table of contents? true/false
type: docs  # Do not modify.

tags:
- Swedish
- Programming
- R
- Correlation
- Visualization
- Scatter plot

# Add menu entry to sidebar.
# - name: Declare this menu item as a parent with ID `name`.
# - weight: Position of link in menu.
menu:
  732G45:
    name: Visualisering av samband
    parent: 732G45
    weight: 5
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(warning=FALSE, message=FALSE, echo = TRUE, eval = TRUE, fig.pos = 'H', fig.height = 4, fig.align = "center", fig.width = 6)

source("packages_732g45.r")

tables("tab1", "Första observationerna i datamaterialet med en grupperingsvariabel Region", display = FALSE)
tables("tab2", "Första observationerna i Iris-data", display = FALSE)
tables("tab3", "Aggregerad datamaterial för iris", display = FALSE)

```

## Spridningsdiagram
När ett datamaterial innehåller flera variabler kan det vara intressant att undersöka vilka (om några) variabler har ett samband med varandra. Detta kan göras på olika sätt, men visualisering i ett spridningsdiagram är ett sätt som möjliggör att se många olika typer av samband mellan **två** variabler.


### R
Vi utgår ifrån tidigare datamaterial och fokuserar på de två kvantitativa variablerna `alder` och `lon` i `aes()`. Här bör vi välja variabler till de olika axlarna som medför en logisk tolkning av vilken variabel som förklarar den andra. Den förklarande variabeln, `x`, anser vi förklara responsvariabeln, `y`, och med dessa variabler är det mer logiskt att `alder` förklarar `lon` för en individ. 

För att skapa ett spridningsdiagram används `geom_point()`. Argument som kan vara av intresse i denna funktion är `color`, `shape` eller `size`.

```{r}

p <- ggplot(exempeldata) + aes(x = alder, y = lon) + geom_point()

p

```

Som vanligt lägger vi till lite extra kod för att ändra utseendet av diagrammet. När det kommer till stödlinjer och spridningsdiagram är syftet med diagrammet att se helheten, det generella sambandet mellan variablerna, mer än specifika värden för enstaka observationer. Detta betyder att stödlinjerna riskerar att ta för mycket fokus från diagrammet istället för att tillföra tydlighet. En lösning på detta är att försvaga styrkan på linjerna eller helt ta bort dem. 

```{r}

p <- 
  p + theme_bw() +
  theme(axis.title.y = 
          element_text(angle = 0, 
                       hjust = 1, 
                       vjust = 0.5), 
        plot.title = 
          element_text(hjust = 0.5),
        plot.subtitle = 
          element_text(hjust = 0.5),
        panel.grid.major.x = 
          element_line(color = "gray"),
        panel.grid.minor.x = 
          element_line(color = "light gray"),
        panel.grid.major.y = 
          element_line(color = "gray"),
        panel.grid.minor.y = 
          element_line(color = "light gray")) + 
  labs(title = "Sambandet mellan ålder och lön",
       x = "Ålder",
       y = "Lön",
       caption = "Källa: Hietala (2019)")
p
```

Då vi pratar om samband är det naturligt att gå vidare till en statistisk metod som kallas för regression som mer i detalj beskriver sambandet mellan variabler. Vi kommer inte gå igenom det så mycket i denna kurs men vi kan fortfarande visualisera den skattade regressionslinje som fås med hjälp av en metod som kallas minsta kvadrat skattning. I R lägger vi till ett till `geom`-objekt till samma diagram. `method = lm` anger att vi vill skatta en linjär modell (**l**inear **m**odel) och `se = FALSE` anger att vi inte vill visa s.k. konfidensband. 

```{r}

p + geom_smooth(method = lm, se = FALSE)

```

#### Visualisering av olika datamaterial i samma diagram
```{r echo = FALSE}

exempeldata_extrem <- exempeldata %>% 
  filter(abs(lon - predict(lm(lon ~ alder, data = exempeldata))) < 12000)

exempeldata_extrem_points <- exempeldata %>% 
  filter(abs(lon - predict(lm(lon ~ alder, data = exempeldata))) > 12000)

```
Om extremvärden skulle finnas i datamaterialet kommer sambandet (och en inritad regressionslinje) riskera att förskjuta det generella samband som finns. Observera att det i praktiken inte är så lätt att bara plocka bort extremvärden från datamaterialet utan en djupare dykning i orsakerna till detta värde. Är extremvärden en felinmatning eller är det ett riktigt värde som är en del av målpopulationen? För att visa hur vi kan använda olika datamaterial i samma diagram kommer vi göra det naïva och plocka bort dessa.

I detta skede av er utbildning rekommenderas att ni identifierar dessa punkter i diagrammet och manuellt tar bort dessa ur data i Excel, sparar en ny fil med nytt namn, och importerar detta nya material till R och sparar det som ett nytt objekt.

Det första vi måste göra för att diagrammet ska bli tydligt är att skapa en grupp (och tillhörande legendrad) för vardera regressionslinje. Detta görs genom att använda `aes(color = "gruppnamn")` inuti `geom_smooth()`. Vi ser nu att en legend lagts till i diagrammet med det angivna namnet på linjen som vi skrivit.

```{r}

p <- 
  p + geom_smooth(aes(color = "med_extrem"), 
                  method = lm, 
                  se = FALSE)

p 

```

För att lägga till den nya regressionslinjen utan extremvärden anges i `geom_smooth()` ett nytt `data`-objekt. Linjen kommer då ritas med samma variabler som angivits innan men utgå från detta materials värden, som saknar de extremvärden som man kan urskilja i materialet.

```{r}

p <- 
  p + geom_smooth(data = exempeldata_extrem,
                  aes(color = "utan_extrem"),
                  method = lm,
                  se = FALSE)
p

```

Legenden kan behöva förtydligas lite och här får vi återigen användning av de gruppnamn som angetts tidigare i koden. Argumentet `name` ger en bättre titel på legenden och i `values` kan vi i vektorn säga specifikt vilka grupper som vi vill ha vissa färger likt `"gruppnamn" = "färg"`. Vi vill också ange bättre etiketter på dessa grupper och detta görs med `labels`-argumentet.

```{r}

p <- 
  p + scale_color_manual(name = "Datamaterial",
                         values = c("med_extrem" = "black",
                                    "utan_extrem" = "orange"),
                         labels = c("med_extrem" = "Hela materialet",
                                    "utan_extrem" = "Utan extremvärden"))

p

```

#### Extra visualisering
Det kanske också kan vara intressant att peka ut vilka observationer som plockas bort vilket kan göras genom att skapa ytterligare ett datamaterial med **enbart** de valda extremvärdena. Vi kan då lägga till ett till `geom_point()` till diagrammet där vi ändrar `shape` till någon annan symbol som tydliggör att dessa har plockats bort.

```{r}

p + geom_point(data = exempeldata_extrem_points,
               shape = "x",
               size = 4)

```

### SAS EG

### SPSS

## Linjediagram

### R

```{r echo = FALSE}

tidsserie_exempel <- read.csv2("data_sets/tidsserie.csv", encoding = "UTF-8")

tidsserie_exempel <- tidsserie_exempel %>% gather(Region, Antal, Hela.landet, Västernorrland, Östergötland)

tidsserie_exempel$Region <- str_replace_all(tidsserie_exempel$Region, pattern = "\\.", " ")

colnames(tidsserie_exempel)[1] <- "År"

```

För att vi ska kunna skapa ett linjediagram över flera serier behöver vi importera data med grupperingskolumner. Även om vi enbart ska visualisera en serie är det bra att få in rutinen att representera data i R på detta sätt. 

Datamaterialet bör alltså se ut som följer:

```{r echo = FALSE}

kable(head(tidsserie_exempel, n = 5), format = "html", caption = tables("tab1")) %>%
  kable_styling(position = "center", full_width = FALSE)

```

När materialet nu innehåller tre variabler (en som visar tid, en som visar vilken grupp värden och år tillhör, samt mätvärdet för den angivna gruppen och året) kan vi påbörja visualiseringen.

Exempeldata innehåller information om antalet anmälda våldsbrott per 100 000 invånare i hela landet, Västernorrland och Östergötland och är hämtat från SCB.


#### En tidsserie
Om endast en serie ska visualiseras kan vi plocka ut en grupp från det tidigare materialet och visualisera endast det. Vi gör detta med `filter()` från `dplyr`-paketet. Kodexemplet gör denna filtrering inuti `ggplot()` men vi skulle lika gärna skapa ett filtrerad data som sparas som ett nytt objekt och använda det senare i `ggplot()`.

```{r}

## Anger att vi endast vill ha en del av data i diagrammet
p <- 
  ggplot(
    filter(.data = tidsserie_exempel, Region == "Hela landet")
    )

```

När vi nu sagt att endast en del av materialet ska visualiseras kan vi som tidigare ange `aes()` där vi nu måste ange både `x` och `y`. På x-axeln vill vi ha tiden, alltså `År` i vårt exempelmaterial, och y-axeln ska innehålla mätvärden, i detta fall variabeln `Antal`. 

För att skapa ett linjediagram används `geom_line()`. I den funktionen finns argument såsom `color`, `linetype`, `size` och liknande som kan användas för att ändra utseendet av diagrammet. Ibland kan linjen bli väldigt smal och svår att se men då kommer argumentet `size` väl till pass.

```{r}

p <- 
  p + aes(x = År, y = Antal) + 
  geom_line(color = "dark orange", size = 1) 

p

```

Som tidigare ändrar vi det visuella och lägger till ytterligare förtydligande texter med liknande koder som innan. Till linjediagram vill vi ofta kunna se både lod- och vågräta avstånd vilket innebär att stödlinjer bör finnas åt båda hållen. Det kan dock vara av intresse att använda och ändra på `panel.grid.minor`-linjerna till en svagare färg för att göra skillnad på de olika stödlinjerna. I exemplet nedan används en mörkare grå färg för `panel.grid.major`.

Något som också introducerats i nedanstående kod är `plot.subtitle` i `theme()` som styr egenskaper av undertiteln som i detta diagram kan vara bra för att förtydliga vilken region som materialet visar. Undertitelns text läggs till i `labs()` och `subtitle`-argumentet.

```{r}

p <- 
  p + theme_bw() + theme(axis.title.y = 
                           element_text(angle = 0, 
                                        hjust = 1, 
                                        vjust = 0.5), 
                         plot.title = 
                           element_text(hjust = 0.5),
                         plot.subtitle = 
                           element_text(hjust = 0.5),
                         panel.grid.major.x = 
                           element_line(color = "dark gray"),
                         panel.grid.minor.x = 
                           element_line(color = "gray"),
                         panel.grid.major.y = 
                           element_line(color = "dark gray"),
                         panel.grid.minor.y = 
                           element_line(color = "gray")) + 
  labs(y = "Antal", 
       x = "År", 
       title = "Antal anmälda våldsbrott per 100 000 invånare", 
       subtitle = "Hela landet",
       caption = "Källa: SCB (2012)")

p 

```

#### Flera tidsserier

För att visualisera flera tidsserier i ett diagram kräver `ggplot2` att datamaterialet ska vara formaterad med en grupperingsvariabel. För att R ska göra skillnad på dessa olika grupper måste `group` och/eller `color` argumentet i `aes` innehålla den grupperingsvariabel som finns i data.


```{r}

p <- ggplot(tidsserie_exempel) + 
  aes(x = År, 
      y = Antal, 
      color = Region, 
      group = Region) + 
  geom_line(size = 1)  

p

```

Som tidigare kan vi nu ändra om flera aspekter av diagrammet men nu måste vi också ändra den legend som skapas från grupperna i `aes()`. När vi nu vill ändra linjefärger är det funktionen `scale_color_manual()` som ska användas, specifikt argumentet `values`. 

Problemet som vi kommer märka är att det är svårt att skapa en vektor med färger som är tydliga nog för olika situationer. Kodexemplet nedan försöker använda delar av `brewer.pal(palette = "Oranges")` tillsammans med en svart grundfärg för att bibehålla en färgstil. 

`brewer.pal()`-funktionen försöker plocka färger från den angivna paletten som skiljer sig från varandra men att ange `n = 3` för de tre regionerna ger en alltför ljus färg som den första. Indexeringen `[-1]` plockar bort den första ljusa färgen och vi lägger istället till svart först i `values`-vektorn.

```{r}

p <- 
  p + scale_color_manual(values = 
                           c("black", brewer.pal(n = 3, "Oranges")[-1])) +
  theme_bw() + theme(axis.title.y = 
                       element_text(angle = 0,
                                    hjust = 1, 
                                    vjust = 0.5),
                     plot.title = 
                       element_text(hjust = 0.5),
                     plot.subtitle = 
                       element_text(hjust = 0.5),
                     panel.grid.major.x = 
                       element_line(color = "dark gray"),
                     panel.grid.minor.x = 
                       element_line(color = "gray"),
                     panel.grid.major.y = 
                       element_line(color = "dark gray"),
                     panel.grid.minor.y = 
                       element_line(color = "gray")) + 
  labs(y = "Antal", 
       x = "År", 
       title = "Antal anmälda våldsbrott per 100 000 invånare", 
       subtitle = "Jämförelse av riket och två län",
       caption = "Källa: SCB (2012)")

p 

```


### SAS EG

### SPSS

## Punktdiagramsmatris

### R

För att skapa en punktdiagramsmatris (spridningsdiagramsmatris) i R behöver vi använda ytterligare ett paket, nämligen `GGally`. I detta paket finns funktionen `ggpairs()` som är (av författarna) skapat som som en samling `ggplot2`-instruktioner som möjliggör skapandet av flera spridningsdiagram inuti ett och samma diagram. Kom ihåg att ladda in detta nya paket i R innan vi fortsätter.

```{r, eval = FALSE}

require(GGally)

```

Datamaterialet som används till detta exempel är ett utav de inbyggda materialen som finns i R, nämligen `iris`. Det innehåller fyra stycken kontinuerliga variabler som beskriver olika mått på blommor och ytterligare en kategorisk variabel som anger vilken art observationen tillhör. Datamaterialet ser ut som följer:

```{r echo = FALSE}

kable(head(iris, n = 5), format = "html", caption = tables("tab2")) %>%
  kable_styling(position = "center", full_width = FALSE)

```

`ggpairs()` kräver vissa argument för att kunna skapa ett diagram;

   - `data`, anger vilket datamaterial som vi vill visualisera,
   - `columns`, anger vilka kolumner ur datamaterialet som ska visualiseras,
   - `title`, anger en titelrubrik för diagrammet,
   - `upper`, anger vad vi vill att den *övre diagonalen* ska visa för information,
   - `diag`, anger vad vi vill att *diagonalen* ska visa för information,
   - `lower`, anger vad vi vill att den *nedre diagonalen* ska visa för information,
   - `axisLabels`, anger inställningar för skalvärden i diagrammet.
   
Notera att `upper`, `diag`, och `lower` måste ange sina argument i en `list()` där variabeltypen måste anges först. I detta exempel kommer vi behöva skriva `list(continuous = )` då variablerna är kontinuerliga. Gå in i dokumentationen för funktionen och i *Details* står vilka andra diagram som kan visualiseras i de olika områdena.

Nedanstående kod kommer skapa ett diagram innehållande spridningsdiagram i den nedre diagonalen över de fyra kontinuerliga variablerna som ligger på position `1:4` i datamaterialet `iris`. Vi väljer också här att plocka bort skalvärden på axlarna då syftet med dessa diagram är att visa sambandet mellan variabler och inte specifika värden som variablerna eller observationer förhåller sig till. Att vi tar bort skalvärden möjliggör också en större rityta som behövs om vi har ett flertal variabler som ska visualiseras.
   
```{r}

p <- ggpairs(data = iris,
             columns = 1:4,
             title = "Samband mellan mått på blommor",
             upper = list(continuous = "points"),
             diag = list(continuous = "blankDiag"),
             lower = list(continuous = "blank"),
             axisLabels = "none"
             ) 

p

```

Som tur är finns det möjlighet att ändra vissa delar av diagrammet för att förtydliga vissa delar.

```{r}

p <- p + theme_bw() + 
  theme(plot.title = element_text(hjust = 0.5))

p

```

#### Färgläggning av observationer beroende på klass
Det kan finnas tillfällen där samband mellan variabler ser olika ut beroende på en kategorisk variabel som inkluderas i datamaterialet. Detta *kan* också inkluderas i dessa diagram, men risken är att det blir för mycket information som trycks ihop på en för liten yta. Tyvärr finns inte ett enkelt sätt att ändra dessa färger eller skapa en legend som tydligt beskriver vilken färg som hör till vilken kategori...

```{r}

ggpairs(data = iris,
        columns = 1:4,
        title = "Samband mellan mått på blommor",
        upper = list(continuous = "points"),
        diag = list(continuous = "blankDiag"),
        lower = list(continuous = "blank"),
        axisLabels = "none",
        mapping = aes(color = Species)
        ) + 
  theme_bw() + 
  theme(plot.title = element_text(hjust = 0.5))


```




## Tree maps
För att skapa en tree map behöver vi först ladda paketet `portfolio` samt hämta hem den förändrade `treemap`-funktionen via `source()`.

```{r}

require(portfolio)

source("https://raw.githubusercontent.com/canadice/visualization_literature/master/treemapbrewer.r")

```

Nu har vi skapat en ny funktion som heter `treemap_brewer()` som har följande argument:

- `id` styr vilken variabel i datamaterialet som används som etikett i varje cell,
- `group` styr vilken variabel som anger vilka/hur många celler som ska skapas,
- `area` styr vilken variabel som bestämmer storleken på cellen,
- `color` styr vilken variabel som bestämmer färgnyansen på cellen,
- `textcol` styr färgen på texten i cellerna,
- `linecol` styr färgen på kantlinjen mellan cellerna,
- `pal` anger en `RColorBrewer` palette med färger som används för färgläggning av cellerna,
- `main` styr diagramrubriken.

För att exemplifiera denna diagramtyp kommer `iris`-data användas igen. En beskrivning av detta material finns tidigare i kodmanualen. Vi vill nu skapa en tree map där vi vill se samband mellan `Sepal.Length` och `Petal.Length` för de tre olika arterna (`Species`) av blommor. För att kunna skapa detta diagram behöver vi ha **en** observation per art så lite databearbetning behöver först göras i antingen Excel eller R. 

Vi vill alltså *aggregera* materialet från det rådata (mikrodata) som anges för varje objekt till gruppvis data (makrodata) för varje art och detta gör vi genom att skapa ett medelvärde per art för de två undersökta variablerna. Vi skulle också kunna tänka oss att vi vill summera de olika arternas mått men i detta material är det nog lämpligare att titta på de genomsnittliga längderna som en egenskap av arten.

Nedanstående kod använder sig utav `dplyr`-paketets funktioner för databearbetning som kommer tas upp mycket mer i Programmering i R under vårterminen.

```{r}

iris_agg <- iris %>% group_by(Species) %>% summarise(sepal_mean = mean(Sepal.Length), 
                                                     petal_mean = mean(Petal.Length))

kable(iris_agg, format = "html", caption = tables("tab3")) %>%
  kable_styling(position = "center", full_width = FALSE)

```

Nu har vi datamaterialet enligt det format som behövs för att skapa en tree map, vi har två kontinuerliga variabler samt en kategorisk variabel. Notera att vi i denna funktion måste ange *datamaterialet$variabelnamnet* för att lägga till variablerna som vi vill använda i funktionen.

```{r}

treemap_brewer(id = iris_agg$Species, 
               group = iris_agg$Species, 
               area = iris_agg$sepal_mean,
               color = iris_agg$petal_mean,
               textcol = "black",
               linecol = "black",
               pal = "Oranges",
               main = "Tree map över olika arter av blommor")

```

**Tänk på att i figurbeskrivningen ange vilka variabler som styr storleken och färgen i diagrammet!**

## Parallellkoordinatdiagram

Denna sorts diagram ämnar att identifiera *kluster* av observationer i ett datamaterial, samt att kunna se korrelationen mellan intilliggande variabler. För att skapa diagrammet används `ggparcoord()` ur paketet `GGally` som vi tittat på tidigare. 

Argumenten som vi är intresserade av är:

- `data` som anger vilket material som ska visualiseras,
- `col` som anger vilka kolumnindex som ska visualiseras,
- `scale` som **alltid** ska vara `"uniminmax"` för att standardisera y-axeln till samma skalor.

Till detta diagram kan vi använda andra `ggplot2`-funktionalitet för text och estetik.

```{r}

ggparcoord(data = iris, 
           col = 1:4,
           scale = "uniminmax") +
  # Lägger till annan estetik likt tidigare diagram
  theme_bw() + 
  theme(axis.title.y = 
          element_text(angle = 0, 
                       hjust = 1, 
                       vjust = 0.5), 
        plot.title = 
          element_text(hjust = 0.5),
        plot.subtitle = 
          element_text(hjust = 0.5),
        panel.grid.major.x = 
          element_line(color = "gray"),
        panel.grid.minor.x = 
          element_line(color = "light gray"),
        panel.grid.major.y = 
          element_line(color = "gray"),
        panel.grid.minor.y = 
          element_line(color = "light gray")) + 
  labs(title = "",
       x = "Variabel",
       y = "Värde",
       caption = "Källa: Anderson, E - The New S Language (1935)")


```

Till hjälp med tolkningen av detta diagram rekommenderas att läsa följande [länk](http://www.jmp.com/support/help/The_Parallel_Plot.shtml). 
